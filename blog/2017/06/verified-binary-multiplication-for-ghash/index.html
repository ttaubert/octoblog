
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>Verified binary multiplication for GHASH - Exploring formal verification (part 3)</title>
    
    <meta name="description" content="Verified binary multiplication for GHASH Exploring formal verification (part 3) June 29, 2017 Previously I introduced some very basic Cryptol and &hellip;">
    <meta content="Tim Taubert" name="author">
    <link href="/stylesheets/bootstrap.min.css" media="screen" rel="stylesheet" type="text/css">
    <link href="/stylesheets/screen.min.css" media="screen" rel="stylesheet" type="text/css">
    <link href="/stylesheets/tables.css" media="screen" rel="stylesheet" type="text/css">
    <link href="/favicon.ico" rel="icon" type="image/ico">
    <link href="/atom.xml" rel="alternate" title="Tim Taubert" type="application/atom+xml">
  </head>


<body>
  <section id="wrapper">
    <nav class="navbar navbar-static-top">
  <div class="container">
    <div class="navbar-header">
      <a class="navbar-brand" href="/">Tim Taubert</a>
    </div>
    <div id="navbar">
      <ul class="nav navbar-nav navbar-right">
        <li><a href="/">Blog</a></li>
        <li><a href="/talks">Talks</a></li>
        <li><a href="https://twitter.com/ttaubert">Twitter</a></li>
        <li><a href="https://github.com/ttaubert">GitHub</a></li>
      </ul>
    </div>
  </div>
</nav>

    <article>
  <header id="article-header">
    <div class="container">
      <h1>Verified binary multiplication for GHASH</h1>
      <h2>Exploring formal verification (part 3)</h2>
    </div>
  </header>

  <div class="container">
    <time pubdate="pubdate">June 29, 2017</time>
    <p><a href="/blog/2017/02/simple-cryptol-specifications/">Previously</a> I introduced some very basic Cryptol and SAWScript, and explained how to reason about the correctness of constant-time integer multiplication written in C/C++.</p>

<p>In this post I will touch on using formal verification as part of the code review process, in particular show how, by using the <a href="http://saw.galois.com/">Software Analysis Workbench</a>, we saved ourselves hours of debugging when rewriting the GHASH implementation for NSS.</p>

<h2>What&rsquo;s GHASH again?</h2>

<p>GHASH is part of the <a href="https://en.wikipedia.org/wiki/Galois/Counter_Mode">Galois/Counter Mode</a>, a mode of operation for block ciphers. AES-GCM for example uses <a href="https://en.wikipedia.org/wiki/Advanced_Encryption_Standard">AES</a> as the block cipher for encryption, and appends a tag generated by the GHASH function, thereby ensuring integrity and authenticity.</p>

<p>The core of GHASH is multiplication in GF(2<sup>128</sup>), a characteristic-two finite field with coefficients in GF(2); they&rsquo;re either zero or one. Polynomials in GF(2<sup>m</sup>) can be represented as m-bit numbers, with each bit corresponding to a term&rsquo;s coefficient. In GF(2<sup>3</sup>) for example, <code>x^2 + 1</code> may be represented as the binary number <code>0b101 = 5</code>.</p>

<p>Additions and subtractions in finite fields are &ldquo;carry-less&rdquo; because the coefficients must be in GF(p), for any GF(p<sup>m</sup>). As <code>x * y</code> is equivalent to adding <code>x</code> to itself <code>y</code> times, we can call multiplication in finite fields &ldquo;carry-less&rdquo; too. In GF(2) addition is simply XOR, so we can say that multiplication in GF(2<sup>m</sup>) is equal to binary multiplication without carries.</p>

<p>Note that the term carry-less only makes sense when talking about GF(2<sup>m</sup>) fields that are easily represented as binary numbers. Otherwise one would rather talk about multiplication in finite fields without comparing it to standard integer multiplication.</p>

<p>Franziskus&#8217; post nicely describes <a href="https://www.franziskuskiefer.de/web/improving-aes-gcm-performance-in-nss/">why and how we updated our AES-GCM code in NSS</a>. In case a user&rsquo;s CPU is not equipped with the <a href="https://en.wikipedia.org/wiki/CLMUL_instruction_set">Carry-less Multiplication (CLMUL) instruction set</a>, we need to provide a fallback and implement carry-less, constant-time binary multiplication ourselves, using standard integer multiplication with carry.</p>

<h2>bmul() for 32-bit machines</h2>

<p>The basic implementation of our binary multiplication algorithm is taken straight from Thomas Pornin&rsquo;s excellent <a href="https://www.bearssl.org/constanttime.html#ghash-for-gcm">constant-time crypto post</a>. To support 32-bit machines the best we can do is multiply two <code>uint32_t</code> numbers and store the result in a <code>uint64_t</code>.</p>

<p>For the full GHASH, <a href="https://en.wikipedia.org/wiki/Karatsuba_algorithm">Karatsuba decomposition</a> is used: multiplication of two 128-bit integers is broken down into nine calls to <code>bmul32(x, y, ...)</code>. Let&rsquo;s take a look at the actual implementation:</p>

<figure class='code'><div class="highlight"><pre><span class="cm">/* Binary multiplication x * y = r_high &lt;&lt; 32 | r_low. */</span>
<span class="k">void</span>
<span class="nf">bmul32</span><span class="p">(</span><span class="k">uint32_t</span> <span class="n">x</span><span class="p">,</span> <span class="k">uint32_t</span> <span class="n">y</span><span class="p">,</span> <span class="k">uint32_t</span> <span class="o">*</span><span class="n">r_high</span><span class="p">,</span> <span class="k">uint32_t</span> <span class="o">*</span><span class="n">r_low</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">uint32_t</span> <span class="n">x0</span><span class="p">,</span> <span class="n">x1</span><span class="p">,</span> <span class="n">x2</span><span class="p">,</span> <span class="n">x3</span><span class="p">;</span>
    <span class="k">uint32_t</span> <span class="n">y0</span><span class="p">,</span> <span class="n">y1</span><span class="p">,</span> <span class="n">y2</span><span class="p">,</span> <span class="n">y3</span><span class="p">;</span>
    <span class="k">uint32_t</span> <span class="n">m1</span> <span class="o">=</span> <span class="p">(</span><span class="k">uint32_t</span><span class="p">)</span><span class="mh">0x11111111</span><span class="p">;</span>
    <span class="k">uint32_t</span> <span class="n">m2</span> <span class="o">=</span> <span class="p">(</span><span class="k">uint32_t</span><span class="p">)</span><span class="mh">0x22222222</span><span class="p">;</span>
    <span class="k">uint32_t</span> <span class="n">m4</span> <span class="o">=</span> <span class="p">(</span><span class="k">uint32_t</span><span class="p">)</span><span class="mh">0x44444444</span><span class="p">;</span>
    <span class="k">uint32_t</span> <span class="n">m8</span> <span class="o">=</span> <span class="p">(</span><span class="k">uint32_t</span><span class="p">)</span><span class="mh">0x88888888</span><span class="p">;</span>
    <span class="k">uint64_t</span> <span class="n">z0</span><span class="p">,</span> <span class="n">z1</span><span class="p">,</span> <span class="n">z2</span><span class="p">,</span> <span class="n">z3</span><span class="p">;</span>
    <span class="k">uint64_t</span> <span class="n">z</span><span class="p">;</span>

    <span class="cm">/* Apply bitmasks. */</span>
    <span class="n">x0</span> <span class="o">=</span> <span class="n">x</span> <span class="o">&amp;</span> <span class="n">m1</span><span class="p">;</span>
    <span class="n">x1</span> <span class="o">=</span> <span class="n">x</span> <span class="o">&amp;</span> <span class="n">m2</span><span class="p">;</span>
    <span class="n">x2</span> <span class="o">=</span> <span class="n">x</span> <span class="o">&amp;</span> <span class="n">m4</span><span class="p">;</span>
    <span class="n">x3</span> <span class="o">=</span> <span class="n">x</span> <span class="o">&amp;</span> <span class="n">m8</span><span class="p">;</span>
    <span class="n">y0</span> <span class="o">=</span> <span class="n">y</span> <span class="o">&amp;</span> <span class="n">m1</span><span class="p">;</span>
    <span class="n">y1</span> <span class="o">=</span> <span class="n">y</span> <span class="o">&amp;</span> <span class="n">m2</span><span class="p">;</span>
    <span class="n">y2</span> <span class="o">=</span> <span class="n">y</span> <span class="o">&amp;</span> <span class="n">m4</span><span class="p">;</span>
    <span class="n">y3</span> <span class="o">=</span> <span class="n">y</span> <span class="o">&amp;</span> <span class="n">m8</span><span class="p">;</span>

    <span class="cm">/* Integer multiplication (16 times). */</span>
    <span class="n">z0</span> <span class="o">=</span> <span class="p">((</span><span class="k">uint64_t</span><span class="p">)</span><span class="n">x0</span> <span class="o">*</span> <span class="n">y0</span><span class="p">)</span> <span class="o">^</span> <span class="p">((</span><span class="k">uint64_t</span><span class="p">)</span><span class="n">x1</span> <span class="o">*</span> <span class="n">y3</span><span class="p">)</span> <span class="o">^</span>
         <span class="p">((</span><span class="k">uint64_t</span><span class="p">)</span><span class="n">x2</span> <span class="o">*</span> <span class="n">y2</span><span class="p">)</span> <span class="o">^</span> <span class="p">((</span><span class="k">uint64_t</span><span class="p">)</span><span class="n">x3</span> <span class="o">*</span> <span class="n">y1</span><span class="p">);</span>
    <span class="n">z1</span> <span class="o">=</span> <span class="p">((</span><span class="k">uint64_t</span><span class="p">)</span><span class="n">x0</span> <span class="o">*</span> <span class="n">y1</span><span class="p">)</span> <span class="o">^</span> <span class="p">((</span><span class="k">uint64_t</span><span class="p">)</span><span class="n">x1</span> <span class="o">*</span> <span class="n">y0</span><span class="p">)</span> <span class="o">^</span>
         <span class="p">((</span><span class="k">uint64_t</span><span class="p">)</span><span class="n">x2</span> <span class="o">*</span> <span class="n">y3</span><span class="p">)</span> <span class="o">^</span> <span class="p">((</span><span class="k">uint64_t</span><span class="p">)</span><span class="n">x3</span> <span class="o">*</span> <span class="n">y2</span><span class="p">);</span>
    <span class="n">z2</span> <span class="o">=</span> <span class="p">((</span><span class="k">uint64_t</span><span class="p">)</span><span class="n">x0</span> <span class="o">*</span> <span class="n">y2</span><span class="p">)</span> <span class="o">^</span> <span class="p">((</span><span class="k">uint64_t</span><span class="p">)</span><span class="n">x1</span> <span class="o">*</span> <span class="n">y1</span><span class="p">)</span> <span class="o">^</span>
         <span class="p">((</span><span class="k">uint64_t</span><span class="p">)</span><span class="n">x2</span> <span class="o">*</span> <span class="n">y0</span><span class="p">)</span> <span class="o">^</span> <span class="p">((</span><span class="k">uint64_t</span><span class="p">)</span><span class="n">x3</span> <span class="o">*</span> <span class="n">y3</span><span class="p">);</span>
    <span class="n">z3</span> <span class="o">=</span> <span class="p">((</span><span class="k">uint64_t</span><span class="p">)</span><span class="n">x0</span> <span class="o">*</span> <span class="n">y3</span><span class="p">)</span> <span class="o">^</span> <span class="p">((</span><span class="k">uint64_t</span><span class="p">)</span><span class="n">x1</span> <span class="o">*</span> <span class="n">y2</span><span class="p">)</span> <span class="o">^</span>
         <span class="p">((</span><span class="k">uint64_t</span><span class="p">)</span><span class="n">x2</span> <span class="o">*</span> <span class="n">y1</span><span class="p">)</span> <span class="o">^</span> <span class="p">((</span><span class="k">uint64_t</span><span class="p">)</span><span class="n">x3</span> <span class="o">*</span> <span class="n">y0</span><span class="p">);</span>

    <span class="cm">/* Merge results. */</span>
    <span class="n">z0</span> <span class="o">&amp;=</span> <span class="p">((</span><span class="k">uint64_t</span><span class="p">)</span><span class="n">m1</span> <span class="o">&lt;&lt;</span> <span class="mi">32</span><span class="p">)</span> <span class="o">|</span> <span class="n">m1</span><span class="p">;</span>
    <span class="n">z1</span> <span class="o">&amp;=</span> <span class="p">((</span><span class="k">uint64_t</span><span class="p">)</span><span class="n">m2</span> <span class="o">&lt;&lt;</span> <span class="mi">32</span><span class="p">)</span> <span class="o">|</span> <span class="n">m2</span><span class="p">;</span>
    <span class="n">z2</span> <span class="o">&amp;=</span> <span class="p">((</span><span class="k">uint64_t</span><span class="p">)</span><span class="n">m4</span> <span class="o">&lt;&lt;</span> <span class="mi">32</span><span class="p">)</span> <span class="o">|</span> <span class="n">m4</span><span class="p">;</span>
    <span class="n">z3</span> <span class="o">&amp;=</span> <span class="p">((</span><span class="k">uint64_t</span><span class="p">)</span><span class="n">m8</span> <span class="o">&lt;&lt;</span> <span class="mi">32</span><span class="p">)</span> <span class="o">|</span> <span class="n">m8</span><span class="p">;</span>
    <span class="n">z</span> <span class="o">=</span> <span class="n">z0</span> <span class="o">|</span> <span class="n">z1</span> <span class="o">|</span> <span class="n">z2</span> <span class="o">|</span> <span class="n">z3</span><span class="p">;</span>
    <span class="o">*</span><span class="n">r_high</span> <span class="o">=</span> <span class="p">(</span><span class="k">uint32_t</span><span class="p">)(</span><span class="n">z</span> <span class="o">&gt;&gt;</span> <span class="mi">32</span><span class="p">);</span>
    <span class="o">*</span><span class="n">r_low</span> <span class="o">=</span> <span class="p">(</span><span class="k">uint32_t</span><span class="p">)</span><span class="n">z</span><span class="p">;</span>
<span class="p">}</span>
</pre></div></figure>


<p>Thomas&#8217; explanation is not too hard to follow. The main idea behind the algorithm are the bitmasks <code>m1 = 0b00010001...</code>, <code>m2 = 0b00100010...</code>, <code>m4 = 0b01000100...</code>, and <code>m8 = 0b10001000...</code>. They respectively have the first, second, third, and fourth bit of every nibble set. This leaves &ldquo;holes&rdquo; of three bits between each &ldquo;data bit&rdquo;, so that with those applied at most a quarter of the 32 bits are equal to one.</p>

<p>Per standard integer multiplication, eight times eight bits will at most add eight carry bits of value one together, thus we need sufficiently sized holes per digit that can hold the value <code>8 = 0b1000</code>. Three-bit holes are big enough to prevent carries from &ldquo;spilling&rdquo; over, they could even handle up to <code>15 = 0b1111</code> data bits in each of the two integer operands.</p>

<h2>Review, tests, and verification</h2>

<p>The first version of the patch came with a bunch of new tests, the vectors taken from the <a href="http://csrc.nist.gov/groups/ST/toolkit/BCM/documents/proposedmodes/gcm/">GCM specification</a>. We previously had no such low-level coverage, all we had were a number of high-level AES-GCM tests.</p>

<p>When reviewing, after looking at the patch itself and applying it locally to see whether it builds and tests succeed, the next step I wanted to try was to write a Cryptol specification to prove the correctness of <code>bmul32()</code>. Thanks to the built-in <code>pmult</code> function that took only a few minutes.</p>

<figure class='code'><div class="highlight"><pre><span class="err">m</span> <span class="err">&lt;-</span> <span class="k">llvm_load_module</span> <span class="s2">&quot;bmul.bc&quot;</span><span class="err">;</span>

<span class="k">let</span> <span class="err">{{</span>
  <span class="err">bmul32</span> <span class="err">:</span> <span class="err">[32]</span> <span class="err">-&gt;</span> <span class="err">[32]</span> <span class="err">-&gt;</span> <span class="err">([32],</span> <span class="err">[32])</span>
  <span class="err">bmul32</span> <span class="err">a</span> <span class="err">b</span> <span class="err">=</span> <span class="err">(</span><span class="k">take</span><span class="err">`{32}</span> <span class="err">prod,</span> <span class="k">drop</span><span class="err">`{32}</span> <span class="err">prod)</span>
      <span class="k">where</span> <span class="err">prod</span> <span class="err">=</span> <span class="err">pad</span> <span class="err">(</span><span class="k">pmult</span> <span class="err">a</span> <span class="err">b)</span>
            <span class="err">pad</span> <span class="err">x</span> <span class="err">=</span> <span class="k">zero</span> <span class="err">#</span> <span class="err">x</span>
<span class="err">}};</span>
</pre></div></figure>


<p>The SAWScript needed to properly parse the LLVM bitcode and formulate the equivalence proof is straightforward, it&rsquo;s basically the same as shown in the previous post.</p>

<figure class='code'><div class="highlight"><pre><span class="k">llvm_verify</span> <span class="err">m</span> <span class="s2">&quot;bmul32&quot;</span> <span class="err">[]</span> <span class="k">do</span> <span class="err">{</span>
  <span class="err">x</span> <span class="err">&lt;-</span> <span class="k">llvm_var</span> <span class="s2">&quot;x&quot;</span> <span class="err">(</span><span class="k">llvm_int</span> <span class="err">32);</span>
  <span class="err">y</span> <span class="err">&lt;-</span> <span class="k">llvm_var</span> <span class="s2">&quot;y&quot;</span> <span class="err">(</span><span class="k">llvm_int</span> <span class="err">32);</span>
  <span class="k">llvm_ptr</span> <span class="s2">&quot;r_high&quot;</span> <span class="err">(</span><span class="k">llvm_int</span> <span class="err">32);</span>
  <span class="err">r_high</span> <span class="err">&lt;-</span> <span class="k">llvm_var</span> <span class="s2">&quot;*r_high&quot;</span> <span class="err">(</span><span class="k">llvm_int</span> <span class="err">32);</span>
  <span class="k">llvm_ptr</span> <span class="s2">&quot;r_low&quot;</span> <span class="err">(</span><span class="k">llvm_int</span> <span class="err">32);</span>
  <span class="err">r_low</span> <span class="err">&lt;-</span> <span class="k">llvm_var</span> <span class="s2">&quot;*r_low&quot;</span> <span class="err">(</span><span class="k">llvm_int</span> <span class="err">32);</span>

  <span class="k">let</span> <span class="err">res</span> <span class="err">=</span> <span class="err">{{</span> <span class="err">bmul32</span> <span class="err">x</span> <span class="err">y</span> <span class="err">}};</span>
  <span class="k">llvm_ensure_eq</span> <span class="s2">&quot;*r_high&quot;</span> <span class="err">{{</span> <span class="err">res.0</span> <span class="err">}};</span>
  <span class="k">llvm_ensure_eq</span> <span class="s2">&quot;*r_low&quot;</span> <span class="err">{{</span> <span class="err">res.1</span> <span class="err">}};</span>

  <span class="k">llvm_verify_tactic</span> <span class="err">abc;</span>
<span class="err">};</span>
</pre></div></figure>


<p>Compile to bitcode and run SAW. After just a few seconds it will tell us it succeeded in proving equivalency of both implementations.</p>

<figure class='code'><div class="highlight"><pre>$ saw bmul.saw
Loading module Cryptol
Loading file &quot;bmul.saw&quot;
Successfully verified @bmul32
</pre></div></figure>


<h2>bmul() for 64-bit machines</h2>

<p><code>bmul32()</code> is called nine times, each time performing 16 multiplications. That&rsquo;s 144 multiplications in total for one GHASH evaluation. If we had a <code>bmul64()</code> for 128-bit multiplication with <code>uint128_t</code> we&rsquo;d need to call it only thrice.</p>

<p>The naive approach taken in the first patch revision was to just double the bitsize of the arguments and variables, and also extend the bitmasks. If you paid close attention to the previous section you might notice a problem here already. If not, it will become clear in a few moments.</p>

<figure class='code'><div class="highlight"><pre><span class="k">typedef</span> <span class="k">unsigned</span> <span class="n">__int128</span> <span class="k">uint128_t</span><span class="p">;</span>

<span class="cm">/* Binary multiplication x * y = r_high &lt;&lt; 64 | r_low. */</span>
<span class="k">void</span>
<span class="nf">bmul64</span><span class="p">(</span><span class="k">uint64_t</span> <span class="n">x</span><span class="p">,</span> <span class="k">uint64_t</span> <span class="n">y</span><span class="p">,</span> <span class="k">uint64_t</span> <span class="o">*</span><span class="n">r_high</span><span class="p">,</span> <span class="k">uint64_t</span> <span class="o">*</span><span class="n">r_low</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">uint64_t</span> <span class="n">x0</span><span class="p">,</span> <span class="n">x1</span><span class="p">,</span> <span class="n">x2</span><span class="p">,</span> <span class="n">x3</span><span class="p">;</span>
    <span class="k">uint64_t</span> <span class="n">y0</span><span class="p">,</span> <span class="n">y1</span><span class="p">,</span> <span class="n">y2</span><span class="p">,</span> <span class="n">y3</span><span class="p">;</span>
    <span class="k">uint64_t</span> <span class="n">m1</span> <span class="o">=</span> <span class="p">(</span><span class="k">uint64_t</span><span class="p">)</span><span class="mh">0x1111111111111111</span><span class="p">;</span>
    <span class="k">uint64_t</span> <span class="n">m2</span> <span class="o">=</span> <span class="p">(</span><span class="k">uint64_t</span><span class="p">)</span><span class="mh">0x2222222222222222</span><span class="p">;</span>
    <span class="k">uint64_t</span> <span class="n">m4</span> <span class="o">=</span> <span class="p">(</span><span class="k">uint64_t</span><span class="p">)</span><span class="mh">0x4444444444444444</span><span class="p">;</span>
    <span class="k">uint64_t</span> <span class="n">m8</span> <span class="o">=</span> <span class="p">(</span><span class="k">uint64_t</span><span class="p">)</span><span class="mh">0x8888888888888888</span><span class="p">;</span>
    <span class="k">uint128_t</span> <span class="n">z0</span><span class="p">,</span> <span class="n">z1</span><span class="p">,</span> <span class="n">z2</span><span class="p">,</span> <span class="n">z3</span><span class="p">;</span>
    <span class="k">uint128_t</span> <span class="n">z</span><span class="p">;</span>

    <span class="cm">/* Apply bitmasks. */</span>
    <span class="n">x0</span> <span class="o">=</span> <span class="n">x</span> <span class="o">&amp;</span> <span class="n">m1</span><span class="p">;</span>
    <span class="n">x1</span> <span class="o">=</span> <span class="n">x</span> <span class="o">&amp;</span> <span class="n">m2</span><span class="p">;</span>
    <span class="n">x2</span> <span class="o">=</span> <span class="n">x</span> <span class="o">&amp;</span> <span class="n">m4</span><span class="p">;</span>
    <span class="n">x3</span> <span class="o">=</span> <span class="n">x</span> <span class="o">&amp;</span> <span class="n">m8</span><span class="p">;</span>
    <span class="n">y0</span> <span class="o">=</span> <span class="n">y</span> <span class="o">&amp;</span> <span class="n">m1</span><span class="p">;</span>
    <span class="n">y1</span> <span class="o">=</span> <span class="n">y</span> <span class="o">&amp;</span> <span class="n">m2</span><span class="p">;</span>
    <span class="n">y2</span> <span class="o">=</span> <span class="n">y</span> <span class="o">&amp;</span> <span class="n">m4</span><span class="p">;</span>
    <span class="n">y3</span> <span class="o">=</span> <span class="n">y</span> <span class="o">&amp;</span> <span class="n">m8</span><span class="p">;</span>

    <span class="cm">/* Integer multiplication (16 times). */</span>
    <span class="n">z0</span> <span class="o">=</span> <span class="p">((</span><span class="k">uint128_t</span><span class="p">)</span><span class="n">x0</span> <span class="o">*</span> <span class="n">y0</span><span class="p">)</span> <span class="o">^</span> <span class="p">((</span><span class="k">uint128_t</span><span class="p">)</span><span class="n">x1</span> <span class="o">*</span> <span class="n">y3</span><span class="p">)</span> <span class="o">^</span>
         <span class="p">((</span><span class="k">uint128_t</span><span class="p">)</span><span class="n">x2</span> <span class="o">*</span> <span class="n">y2</span><span class="p">)</span> <span class="o">^</span> <span class="p">((</span><span class="k">uint128_t</span><span class="p">)</span><span class="n">x3</span> <span class="o">*</span> <span class="n">y1</span><span class="p">);</span>
    <span class="n">z1</span> <span class="o">=</span> <span class="p">((</span><span class="k">uint128_t</span><span class="p">)</span><span class="n">x0</span> <span class="o">*</span> <span class="n">y1</span><span class="p">)</span> <span class="o">^</span> <span class="p">((</span><span class="k">uint128_t</span><span class="p">)</span><span class="n">x1</span> <span class="o">*</span> <span class="n">y0</span><span class="p">)</span> <span class="o">^</span>
         <span class="p">((</span><span class="k">uint128_t</span><span class="p">)</span><span class="n">x2</span> <span class="o">*</span> <span class="n">y3</span><span class="p">)</span> <span class="o">^</span> <span class="p">((</span><span class="k">uint128_t</span><span class="p">)</span><span class="n">x3</span> <span class="o">*</span> <span class="n">y2</span><span class="p">);</span>
    <span class="n">z2</span> <span class="o">=</span> <span class="p">((</span><span class="k">uint128_t</span><span class="p">)</span><span class="n">x0</span> <span class="o">*</span> <span class="n">y2</span><span class="p">)</span> <span class="o">^</span> <span class="p">((</span><span class="k">uint128_t</span><span class="p">)</span><span class="n">x1</span> <span class="o">*</span> <span class="n">y1</span><span class="p">)</span> <span class="o">^</span>
         <span class="p">((</span><span class="k">uint128_t</span><span class="p">)</span><span class="n">x2</span> <span class="o">*</span> <span class="n">y0</span><span class="p">)</span> <span class="o">^</span> <span class="p">((</span><span class="k">uint128_t</span><span class="p">)</span><span class="n">x3</span> <span class="o">*</span> <span class="n">y3</span><span class="p">);</span>
    <span class="n">z3</span> <span class="o">=</span> <span class="p">((</span><span class="k">uint128_t</span><span class="p">)</span><span class="n">x0</span> <span class="o">*</span> <span class="n">y3</span><span class="p">)</span> <span class="o">^</span> <span class="p">((</span><span class="k">uint128_t</span><span class="p">)</span><span class="n">x1</span> <span class="o">*</span> <span class="n">y2</span><span class="p">)</span> <span class="o">^</span>
         <span class="p">((</span><span class="k">uint128_t</span><span class="p">)</span><span class="n">x2</span> <span class="o">*</span> <span class="n">y1</span><span class="p">)</span> <span class="o">^</span> <span class="p">((</span><span class="k">uint128_t</span><span class="p">)</span><span class="n">x3</span> <span class="o">*</span> <span class="n">y0</span><span class="p">);</span>

    <span class="cm">/* Merge results. */</span>
    <span class="n">z0</span> <span class="o">&amp;=</span> <span class="p">((</span><span class="k">uint128_t</span><span class="p">)</span><span class="n">m1</span> <span class="o">&lt;&lt;</span> <span class="mi">64</span><span class="p">)</span> <span class="o">|</span> <span class="n">m1</span><span class="p">;</span>
    <span class="n">z1</span> <span class="o">&amp;=</span> <span class="p">((</span><span class="k">uint128_t</span><span class="p">)</span><span class="n">m2</span> <span class="o">&lt;&lt;</span> <span class="mi">64</span><span class="p">)</span> <span class="o">|</span> <span class="n">m2</span><span class="p">;</span>
    <span class="n">z2</span> <span class="o">&amp;=</span> <span class="p">((</span><span class="k">uint128_t</span><span class="p">)</span><span class="n">m4</span> <span class="o">&lt;&lt;</span> <span class="mi">64</span><span class="p">)</span> <span class="o">|</span> <span class="n">m4</span><span class="p">;</span>
    <span class="n">z3</span> <span class="o">&amp;=</span> <span class="p">((</span><span class="k">uint128_t</span><span class="p">)</span><span class="n">m8</span> <span class="o">&lt;&lt;</span> <span class="mi">64</span><span class="p">)</span> <span class="o">|</span> <span class="n">m8</span><span class="p">;</span>
    <span class="n">z</span> <span class="o">=</span> <span class="n">z0</span> <span class="o">|</span> <span class="n">z1</span> <span class="o">|</span> <span class="n">z2</span> <span class="o">|</span> <span class="n">z3</span><span class="p">;</span>
    <span class="o">*</span><span class="n">r_high</span> <span class="o">=</span> <span class="p">(</span><span class="k">uint64_t</span><span class="p">)(</span><span class="n">z</span> <span class="o">&gt;&gt;</span> <span class="mi">64</span><span class="p">);</span>
    <span class="o">*</span><span class="n">r_low</span> <span class="o">=</span> <span class="p">(</span><span class="k">uint64_t</span><span class="p">)</span><span class="n">z</span><span class="p">;</span>
<span class="p">}</span>
</pre></div></figure>


<h2>Tests and another equivalence proof</h2>

<p>The above version of <code>bmul64()</code> <em>passed</em> the GHASH test vectors with flying colors. That tricked reviewers into thinking it looked just fine, even if they just learned about the basic algorithm idea. Fallible humans. Let&rsquo;s update the proofs and see what happens.</p>

<figure class='code'><div class="highlight"><pre><span class="err">bmul</span> <span class="err">:</span> <span class="err">{n,m}</span> <span class="err">(</span><span class="k">fin</span> <span class="err">n,</span> <span class="err">n</span> <span class="err">&gt;=</span> <span class="err">1,</span> <span class="err">m</span> <span class="err">==</span> <span class="err">n*2</span> <span class="err">-</span> <span class="err">1)</span> <span class="err">=&gt;</span> <span class="err">[n]</span> <span class="err">-&gt;</span> <span class="err">[n]</span> <span class="err">-&gt;</span> <span class="err">([n],</span> <span class="err">[n])</span>
<span class="err">bmul</span> <span class="err">a</span> <span class="err">b</span> <span class="err">=</span> <span class="err">(</span><span class="k">take</span><span class="err">`{n}</span> <span class="err">prod,</span> <span class="k">drop</span><span class="err">`{n}</span> <span class="err">prod)</span>
    <span class="k">where</span> <span class="err">prod</span> <span class="err">=</span> <span class="err">pad</span> <span class="err">(</span><span class="k">pmult</span> <span class="err">a</span> <span class="err">b</span> <span class="err">:</span> <span class="err">[m])</span>
          <span class="err">pad</span> <span class="err">x</span> <span class="err">=</span> <span class="k">zero</span> <span class="err">#</span> <span class="err">x</span>
</pre></div></figure>


<p>Instead of hardcoding <code>bmul</code> for 32-bit integers we use polymorphic types <code>m</code> and <code>n</code> to denote the size in bits. <code>m</code> is mostly a helper to make it a tad more readable. We can now reason about carry-less n-bit binary multiplication.</p>

<p>Duplicating the SAWScript spec and running <code>:s/32/64</code> is easy, but certainly nicer is adding a function that takes <code>n</code> as a parameter and returns a spec for n-bit arguments.</p>

<figure class='code'><div class="highlight"><pre><span class="k">let</span> <span class="err">SpecBinaryMul</span> <span class="err">n</span> <span class="err">=</span> <span class="k">do</span> <span class="err">{</span>
  <span class="err">x</span> <span class="err">&lt;-</span> <span class="k">llvm_var</span> <span class="s2">&quot;x&quot;</span> <span class="err">(</span><span class="k">llvm_int</span> <span class="err">n);</span>
  <span class="err">y</span> <span class="err">&lt;-</span> <span class="k">llvm_var</span> <span class="s2">&quot;y&quot;</span> <span class="err">(</span><span class="k">llvm_int</span> <span class="err">n);</span>
  <span class="k">llvm_ptr</span> <span class="s2">&quot;r_high&quot;</span> <span class="err">(</span><span class="k">llvm_int</span> <span class="err">n);</span>
  <span class="err">r_high</span> <span class="err">&lt;-</span> <span class="k">llvm_var</span> <span class="s2">&quot;*r_high&quot;</span> <span class="err">(</span><span class="k">llvm_int</span> <span class="err">n);</span>
  <span class="k">llvm_ptr</span> <span class="s2">&quot;r_low&quot;</span> <span class="err">(</span><span class="k">llvm_int</span> <span class="err">n);</span>
  <span class="err">r_low</span> <span class="err">&lt;-</span> <span class="k">llvm_var</span> <span class="s2">&quot;*r_low&quot;</span> <span class="err">(</span><span class="k">llvm_int</span> <span class="err">n);</span>

  <span class="k">let</span> <span class="err">res</span> <span class="err">=</span> <span class="err">{{</span> <span class="err">bmul</span> <span class="err">x</span> <span class="err">y</span> <span class="err">}};</span>
  <span class="k">llvm_ensure_eq</span> <span class="s2">&quot;*r_high&quot;</span> <span class="err">{{</span> <span class="err">res.0</span> <span class="err">}};</span>
  <span class="k">llvm_ensure_eq</span> <span class="s2">&quot;*r_low&quot;</span> <span class="err">{{</span> <span class="err">res.1</span> <span class="err">}};</span>

  <span class="k">llvm_verify_tactic</span> <span class="err">abc;</span>
<span class="err">};</span>

<span class="k">llvm_verify</span> <span class="err">m</span> <span class="s2">&quot;bmul32&quot;</span> <span class="err">[]</span> <span class="err">(SpecBinaryMul</span> <span class="err">32);</span>
<span class="k">llvm_verify</span> <span class="err">m</span> <span class="s2">&quot;bmul64&quot;</span> <span class="err">[]</span> <span class="err">(SpecBinaryMul</span> <span class="err">64);</span>
</pre></div></figure>


<p>We use two instances of the <code>bmul</code> spec to prove correctness of <code>bmul32()</code> and <code>bmul64()</code> sequentially. The second verification will take a lot longer before yielding results.</p>

<figure class='code'><div class="highlight"><pre>$ saw bmul.saw
Loading module Cryptol
Loading file &quot;bmul.saw&quot;
Successfully verified @bmul32
When verifying @bmul64:
Proof of Term *(Term Ident &quot;r_high&quot;) failed.
Counterexample:
  %x: 15554860936645695441
  %y: 17798150062858027007
  lss__alloc0: 262144
  lss__alloc1: 8
Term *(Term Ident &quot;r_high&quot;)
Encountered:  5413984507840984561
Expected:     5413984507840984531
saw: user error (&quot;llvm_verify&quot; (bmul.saw:31:1):
Proof failed.)
</pre></div></figure>


<p><em>Proof failed.</em> As you probably expected by now, the <code>bmul64()</code> implementation is erroneous and SAW gives us a specific counterexample to investigate further. It took us a while to understand the failure but it seems very obvious in hindsight.</p>

<h2>Fixing the bmul64() bitmasks</h2>

<p>As already shown above, bitmasks leaving three-bit holes between data bits can avoid carry-spilling for up to two 15-bit integers. Using every fourth bit of a 64-bit argument however yields 16 data bits each, and carries can thus override data bits. We need bitmasks with four-bit holes.</p>

<figure class='code'><div class="highlight"><pre><span class="cm">/* Binary multiplication x * y = r_high &lt;&lt; 64 | r_low. */</span>
<span class="k">void</span>
<span class="nf">bmul64</span><span class="p">(</span><span class="k">uint64_t</span> <span class="n">x</span><span class="p">,</span> <span class="k">uint64_t</span> <span class="n">y</span><span class="p">,</span> <span class="k">uint64_t</span> <span class="o">*</span><span class="n">r_high</span><span class="p">,</span> <span class="k">uint64_t</span> <span class="o">*</span><span class="n">r_low</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">uint128_t</span> <span class="n">x1</span><span class="p">,</span> <span class="n">x2</span><span class="p">,</span> <span class="n">x3</span><span class="p">,</span> <span class="n">x4</span><span class="p">,</span> <span class="n">x5</span><span class="p">;</span>
    <span class="k">uint128_t</span> <span class="n">y1</span><span class="p">,</span> <span class="n">y2</span><span class="p">,</span> <span class="n">y3</span><span class="p">,</span> <span class="n">y4</span><span class="p">,</span> <span class="n">y5</span><span class="p">;</span>
    <span class="k">uint128_t</span> <span class="n">r</span><span class="p">,</span> <span class="n">z</span><span class="p">;</span>

    <span class="cm">/* Define bitmasks with 4-bit holes. */</span>
    <span class="k">uint128_t</span> <span class="n">m1</span> <span class="o">=</span> <span class="p">(</span><span class="k">uint128_t</span><span class="p">)</span><span class="mh">0x2108421084210842</span> <span class="o">&lt;&lt;</span> <span class="mi">64</span> <span class="o">|</span> <span class="mh">0x1084210842108421</span><span class="p">;</span>
    <span class="k">uint128_t</span> <span class="n">m2</span> <span class="o">=</span> <span class="p">(</span><span class="k">uint128_t</span><span class="p">)</span><span class="mh">0x4210842108421084</span> <span class="o">&lt;&lt;</span> <span class="mi">64</span> <span class="o">|</span> <span class="mh">0x2108421084210842</span><span class="p">;</span>
    <span class="k">uint128_t</span> <span class="n">m3</span> <span class="o">=</span> <span class="p">(</span><span class="k">uint128_t</span><span class="p">)</span><span class="mh">0x8421084210842108</span> <span class="o">&lt;&lt;</span> <span class="mi">64</span> <span class="o">|</span> <span class="mh">0x4210842108421084</span><span class="p">;</span>
    <span class="k">uint128_t</span> <span class="n">m4</span> <span class="o">=</span> <span class="p">(</span><span class="k">uint128_t</span><span class="p">)</span><span class="mh">0x0842108421084210</span> <span class="o">&lt;&lt;</span> <span class="mi">64</span> <span class="o">|</span> <span class="mh">0x8421084210842108</span><span class="p">;</span>
    <span class="k">uint128_t</span> <span class="n">m5</span> <span class="o">=</span> <span class="p">(</span><span class="k">uint128_t</span><span class="p">)</span><span class="mh">0x1084210842108421</span> <span class="o">&lt;&lt;</span> <span class="mi">64</span> <span class="o">|</span> <span class="mh">0x0842108421084210</span><span class="p">;</span>

    <span class="cm">/* Apply bitmasks. */</span>
    <span class="n">x1</span> <span class="o">=</span> <span class="n">x</span> <span class="o">&amp;</span> <span class="n">m1</span><span class="p">;</span>
    <span class="n">y1</span> <span class="o">=</span> <span class="n">y</span> <span class="o">&amp;</span> <span class="n">m1</span><span class="p">;</span>
    <span class="n">x2</span> <span class="o">=</span> <span class="n">x</span> <span class="o">&amp;</span> <span class="n">m2</span><span class="p">;</span>
    <span class="n">y2</span> <span class="o">=</span> <span class="n">y</span> <span class="o">&amp;</span> <span class="n">m2</span><span class="p">;</span>
    <span class="n">x3</span> <span class="o">=</span> <span class="n">x</span> <span class="o">&amp;</span> <span class="n">m3</span><span class="p">;</span>
    <span class="n">y3</span> <span class="o">=</span> <span class="n">y</span> <span class="o">&amp;</span> <span class="n">m3</span><span class="p">;</span>
    <span class="n">x4</span> <span class="o">=</span> <span class="n">x</span> <span class="o">&amp;</span> <span class="n">m4</span><span class="p">;</span>
    <span class="n">y4</span> <span class="o">=</span> <span class="n">y</span> <span class="o">&amp;</span> <span class="n">m4</span><span class="p">;</span>
    <span class="n">x5</span> <span class="o">=</span> <span class="n">x</span> <span class="o">&amp;</span> <span class="n">m5</span><span class="p">;</span>
    <span class="n">y5</span> <span class="o">=</span> <span class="n">y</span> <span class="o">&amp;</span> <span class="n">m5</span><span class="p">;</span>

    <span class="cm">/* Integer multiplication (25 times) and merge results. */</span>
    <span class="n">z</span> <span class="o">=</span> <span class="p">(</span><span class="n">x1</span> <span class="o">*</span> <span class="n">y1</span><span class="p">)</span> <span class="o">^</span> <span class="p">(</span><span class="n">x2</span> <span class="o">*</span> <span class="n">y5</span><span class="p">)</span> <span class="o">^</span> <span class="p">(</span><span class="n">x3</span> <span class="o">*</span> <span class="n">y4</span><span class="p">)</span> <span class="o">^</span> <span class="p">(</span><span class="n">x4</span> <span class="o">*</span> <span class="n">y3</span><span class="p">)</span> <span class="o">^</span> <span class="p">(</span><span class="n">x5</span> <span class="o">*</span> <span class="n">y2</span><span class="p">);</span>
    <span class="n">r</span> <span class="o">=</span> <span class="n">z</span> <span class="o">&amp;</span> <span class="n">m1</span><span class="p">;</span>
    <span class="n">z</span> <span class="o">=</span> <span class="p">(</span><span class="n">x1</span> <span class="o">*</span> <span class="n">y2</span><span class="p">)</span> <span class="o">^</span> <span class="p">(</span><span class="n">x2</span> <span class="o">*</span> <span class="n">y1</span><span class="p">)</span> <span class="o">^</span> <span class="p">(</span><span class="n">x3</span> <span class="o">*</span> <span class="n">y5</span><span class="p">)</span> <span class="o">^</span> <span class="p">(</span><span class="n">x4</span> <span class="o">*</span> <span class="n">y4</span><span class="p">)</span> <span class="o">^</span> <span class="p">(</span><span class="n">x5</span> <span class="o">*</span> <span class="n">y3</span><span class="p">);</span>
    <span class="n">r</span> <span class="o">|=</span> <span class="n">z</span> <span class="o">&amp;</span> <span class="n">m2</span><span class="p">;</span>
    <span class="n">z</span> <span class="o">=</span> <span class="p">(</span><span class="n">x1</span> <span class="o">*</span> <span class="n">y3</span><span class="p">)</span> <span class="o">^</span> <span class="p">(</span><span class="n">x2</span> <span class="o">*</span> <span class="n">y2</span><span class="p">)</span> <span class="o">^</span> <span class="p">(</span><span class="n">x3</span> <span class="o">*</span> <span class="n">y1</span><span class="p">)</span> <span class="o">^</span> <span class="p">(</span><span class="n">x4</span> <span class="o">*</span> <span class="n">y5</span><span class="p">)</span> <span class="o">^</span> <span class="p">(</span><span class="n">x5</span> <span class="o">*</span> <span class="n">y4</span><span class="p">);</span>
    <span class="n">r</span> <span class="o">|=</span> <span class="n">z</span> <span class="o">&amp;</span> <span class="n">m3</span><span class="p">;</span>
    <span class="n">z</span> <span class="o">=</span> <span class="p">(</span><span class="n">x1</span> <span class="o">*</span> <span class="n">y4</span><span class="p">)</span> <span class="o">^</span> <span class="p">(</span><span class="n">x2</span> <span class="o">*</span> <span class="n">y3</span><span class="p">)</span> <span class="o">^</span> <span class="p">(</span><span class="n">x3</span> <span class="o">*</span> <span class="n">y2</span><span class="p">)</span> <span class="o">^</span> <span class="p">(</span><span class="n">x4</span> <span class="o">*</span> <span class="n">y1</span><span class="p">)</span> <span class="o">^</span> <span class="p">(</span><span class="n">x5</span> <span class="o">*</span> <span class="n">y5</span><span class="p">);</span>
    <span class="n">r</span> <span class="o">|=</span> <span class="n">z</span> <span class="o">&amp;</span> <span class="n">m4</span><span class="p">;</span>
    <span class="n">z</span> <span class="o">=</span> <span class="p">(</span><span class="n">x1</span> <span class="o">*</span> <span class="n">y5</span><span class="p">)</span> <span class="o">^</span> <span class="p">(</span><span class="n">x2</span> <span class="o">*</span> <span class="n">y4</span><span class="p">)</span> <span class="o">^</span> <span class="p">(</span><span class="n">x3</span> <span class="o">*</span> <span class="n">y3</span><span class="p">)</span> <span class="o">^</span> <span class="p">(</span><span class="n">x4</span> <span class="o">*</span> <span class="n">y2</span><span class="p">)</span> <span class="o">^</span> <span class="p">(</span><span class="n">x5</span> <span class="o">*</span> <span class="n">y1</span><span class="p">);</span>
    <span class="n">r</span> <span class="o">|=</span> <span class="n">z</span> <span class="o">&amp;</span> <span class="n">m5</span><span class="p">;</span>

    <span class="o">*</span><span class="n">r_high</span> <span class="o">=</span> <span class="p">(</span><span class="k">uint64_t</span><span class="p">)(</span><span class="n">r</span> <span class="o">&gt;&gt;</span> <span class="mi">64</span><span class="p">);</span>
    <span class="o">*</span><span class="n">r_low</span> <span class="o">=</span> <span class="p">(</span><span class="k">uint64_t</span><span class="p">)</span><span class="n">r</span><span class="p">;</span>
<span class="p">}</span>
</pre></div></figure>


<p><code>m1</code>, &hellip;, <code>m5</code> are the new bitmasks. <code>m1</code> equals <code>0b0010000100001...</code>, the others are each shifted by one. As the number of data bits per argument is now <code>64/5 &lt;= n &lt; 64/4</code> we need <code>5*5 = 25</code> multiplications. With three calls to <code>bmul64()</code> that&rsquo;s 75 in total.</p>

<p>Run SAW again and, after about an hour, it will tell us it <em>successfully verified @bmul64</em>.</p>

<figure class='code'><div class="highlight"><pre>$ saw bmul.saw
Loading module Cryptol
Loading file &quot;bmul.saw&quot;
Successfully verified @bmul32
Successfully verified @bmul64
</pre></div></figure>


<p>You might want to take a look at <a href="https://www.bearssl.org/gitweb/?p=BearSSL;a=blob;f=src/hash/ghash_ctmul64.c;h=a46f16fee977f6102abea7f7bcdf169a013c3e8e;hb=5f045c759957fdff8c85716e6af99e10901fdac0">Thomas Pornin&rsquo;s version</a> of <code>bmul64()</code>. This basically is the faulty version that SAW failed to verify, he however works around the overflow by calling it twice, passing arguments reversed bitwise the second time. He invokes <code>bmul64()</code> six times, which results in a total of 96 multiplications.</p>

<h2>Some final thoughts</h2>

<p>One of the takeaways is that even an implementation passing all test vectors given by a spec doesn&rsquo;t need to be correct. That is not too surprising, spec authors can&rsquo;t possibly predict edge cases from implementation approaches they haven&rsquo;t thought about.</p>

<p>Using formal verification as part of the review process was definitely a wise decision. We likely saved hours of debugging intermittently failing connections, or random interoperability problems reported by early testers. I&rsquo;m confident this wouldn&rsquo;t have made it much further down the release line.</p>

<p>We of course added an extra test that covers that specific flaw but the next step definitely should be proper CI integration. The Cryptol code has already been written and there is no reason to not run it on every push. Verifying the full GHASH implementation would be ideal. The Cryptol code is almost trivial:</p>

<figure class='code'><div class="highlight"><pre><span class="err">ghash</span> <span class="err">:</span> <span class="err">[128]</span> <span class="err">-&gt;</span> <span class="err">[128]</span> <span class="err">-&gt;</span> <span class="err">[128]</span> <span class="err">-&gt;</span> <span class="err">([64],</span> <span class="err">[64])</span>
<span class="err">ghash</span> <span class="err">h</span> <span class="err">x</span> <span class="err">buf</span> <span class="err">=</span> <span class="err">(</span><span class="k">take</span><span class="err">`{64}</span> <span class="err">res,</span> <span class="k">drop</span><span class="err">`{64}</span> <span class="err">res)</span>
    <span class="k">where</span> <span class="err">prod</span> <span class="err">=</span> <span class="k">pmod</span> <span class="err">(</span><span class="k">pmult</span> <span class="err">(</span><span class="k">reverse</span> <span class="err">h)</span> <span class="err">xor)</span> <span class="err">&lt;|x^^128</span> <span class="err">+</span> <span class="err">x^^7</span> <span class="err">+</span> <span class="err">x^^2</span> <span class="err">+</span> <span class="err">x</span> <span class="err">+</span> <span class="err">1|&gt;</span>
          <span class="err">xor</span> <span class="err">=</span> <span class="err">(</span><span class="k">reverse</span> <span class="err">x)</span> <span class="err">^</span> <span class="err">(</span><span class="k">reverse</span> <span class="err">buf)</span>
          <span class="err">res</span> <span class="err">=</span> <span class="k">reverse</span> <span class="err">prod</span>
</pre></div></figure>


<p>Proving the multiplication of two 128-bit numbers for a 256-bit product will unfortunately take a very very long time, or maybe not finish at all. Even if it finished after a few days that&rsquo;s not something you want to automatically run on every push. Running it manually every time the code is touched might be an option though.</p>

  </div>
</article>

  </section>

  <footer>
  <div class="container">
    <span class="break">&#8203;</span><div class="section">
      <a class="main" href="/">Tim Taubert</a>
      <span class="job">Security &amp; Crypto Engineer</span>
      <a class="license" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a>
      <a href="https://twitter.com/ttaubert">@ttaubert</a>
    </div>
    <span class="break">&#8203;</span><div class="section short1">
      <span class="job">Security &amp; Crypto Engineer</span>
      <a class="license" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a>
      <a href="https://twitter.com/ttaubert">@ttaubert</a>
    </div>
    <span class="break">&#8203;</span><div class="section short2">
      <a class="license" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a>
      <a href="https://twitter.com/ttaubert">@ttaubert</a>
    </div>
    <div class="section short3">
      <a class="license" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a>
    </div>
  </div>
</footer>

</body>
</html>
