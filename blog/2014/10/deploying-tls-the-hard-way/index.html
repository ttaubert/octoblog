
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>Deploying TLS the hard way - Configuring HTTPS for your domain(s)</title>
    
    <meta name="description" content="Deploying TLS the hard way Configuring HTTPS for your domain(s) October 27, 2014 How does TLS work?
The certificate
(Perfect) Forward Secrecy &hellip;">
    <meta content="Tim Taubert" name="author">
    <link href="/stylesheets/bootstrap.min.css" media="screen" rel="stylesheet" type="text/css">
    <link href="/stylesheets/screen.min.css" media="screen" rel="stylesheet" type="text/css">
    <link href="/stylesheets/tables.css" media="screen" rel="stylesheet" type="text/css">
    <link href="/favicon.ico" rel="icon" type="image/ico">
    <link href="/atom.xml" rel="alternate" title="Tim Taubert" type="application/atom+xml">
  </head>


<body>
  <section id="wrapper">
    <nav class="navbar navbar-static-top">
  <div class="container">
    <div class="navbar-header">
      <a class="navbar-brand" href="/">Tim Taubert</a>
    </div>
    <div id="navbar">
      <ul class="nav navbar-nav navbar-right">
        <li><a href="/">Blog</a></li>
        <li><a href="/talks">Talks</a></li>
        <li><a href="https://twitter.com/ttaubert">Twitter</a></li>
        <li><a href="https://github.com/ttaubert">GitHub</a></li>
      </ul>
    </div>
  </div>
</nav>

    <article>
  <header id="article-header">
    <div class="container">
      <h1>Deploying TLS the hard way</h1>
      <h2>Configuring HTTPS for your domain(s)</h2>
    </div>
  </header>

  <div class="container">
    <time pubdate="pubdate">October 27, 2014</time>
    <blockquote><ol>
<li><a href="#tls">How does TLS work?</a></li>
<li><a href="#the-cert">The certificate</a></li>
<li><a href="#pfs">(Perfect) Forward Secrecy</a></li>
<li><a href="#cipher-suites">Choosing the right cipher suites</a></li>
<li><a href="#hsts">HTTP Strict Transport Security</a></li>
<li><a href="#hsts-preload">HSTS Preload List</a></li>
<li><a href="#ocsp-stapling">OCSP Stapling</a></li>
<li><a href="#hpkp">HTTP Public Key Pinning</a></li>
<li><a href="#attacks">Known attacks</a></li>
</ol>
</blockquote>

<p>Last weekend I finally deployed TLS for <code>timtaubert.de</code> and decided to write up
what I learned on the way hoping that it would be useful for anyone doing the
same. Instead of only giving you a few buzz words I want to provide background
information on how TLS and certain HTTP extensions work and why you should use
them or configure TLS in a certain way.</p>

<p>One thing that bugged me was that most posts only describe what to do but not
necessarily why to do it. I hope you appreciate me going into a little more
detail to end up with the bigger picture of what TLS currently is, so that you
will be able to make informed decisions when deploying yourselves.</p>

<p>To follow this post you will need some basic cryptography knowledge. Whenever
you do not know or understand a concept you should probably just head over to
Wikipedia and take a few minutes or just do it later and maybe re-read the
whole thing.</p>

<blockquote><p>Disclaimer: I am not a security expert or cryptographer but did my best to
research this post thoroughly. Please <a href="https://twitter.com/ttaubert">let me know</a>
of any mistakes I might have made and I will correct them as soon as possible.</p></blockquote>

<h2>But didn&rsquo;t Andy say this is all shit?</h2>

<p>I read <a href="http://wingolog.org/archives/2014/10/17/ffs-ssl">Andy Wingo&rsquo;s blog post</a>
too and I really liked it. Everything he says in there is true. But what is
also true is that TLS with the few add-ons is all we have nowadays and we
better make the folks working for the NSA earn their money instead of not
trying to encrypt traffic at all.</p>

<p>After you finished reading this page, maybe go back to Andy&rsquo;s post and read it
again. You might have a better understanding of what he is ranting about than
you had before if the details of TLS are still dark matter to you.</p>

<h2><a name="tls"></a> So how does TLS work?</h2>

<p>Every TLS connection starts with both parties sharing their supported TLS
versions and cipher suites. As the next step the server sends its
<a href="https://en.wikipedia.org/wiki/X.509#Structure_of_a_certificate">X.509 certificate</a>
to the browser.</p>

<h3>Checking the server&rsquo;s certificate</h3>

<p>The following certificate checks need to be performed:</p>

<ul>
<li>Does the certificate contain the server&rsquo;s hostname?</li>
<li>Was the certificate issued by a CA that is in my list of trusted CAs?</li>
<li>Does the certificate&rsquo;s signature verify using the CA&rsquo;s public key?</li>
<li>Has the certificate expired already?</li>
<li>Was the certificate revoked?</li>
</ul>


<p>All of these are very obvious crucial checks. To query a certificate&rsquo;s
revocation status the browser will use the
<a href="https://tools.ietf.org/html/rfc6960">Online Certificate Status Protocol (OCSP)</a>
which I will describe in more detail in a later section.</p>

<p>After the certificate checks are done and the browser ensured it is talking to
the right host both sides need to agree on secret keys they will use to
communicate with each other.</p>

<h3>Key Exchange using RSA</h3>

<p>A simple key exchange would be to let the client generate a <em>master secret</em>
and encrypt that with the server&rsquo;s public
<a href="https://en.wikipedia.org/wiki/RSA_%28cryptosystem%29">RSA</a> key given by the
certificate. Both client and server would then use that master secret to derive
symmetric encryption keys that will be used throughout this TLS session. An
attacker could however simply record the handshake and session for later, when
breaking the key has become feasible or the machine is suspect to a
vulnerability. They may then use the server&rsquo;s private key to recover the whole
conversation.</p>

<h3>Key Exchange using (EC)DHE</h3>

<p>When using (Elliptic Curve)
<a href="https://en.wikipedia.org/wiki/Diffie-Hellman_key_exchange">Diffie-Hellman</a> as
the key exchange mechanism both sides have to collaborate to generate a master
secret. They generate DH key pairs (which is <em>a lot</em> cheaper than generating
RSA keys) and send their public key to the other party. With the private key
and the other party&rsquo;s public key the shared master secret can be calculated and
then again be used to derive session keys. We can provide
<a href="https://en.wikipedia.org/wiki/Forward_secrecy">Forward Secrecy</a> when using
ephemeral DH key pairs. See the section below on how to enable it.</p>

<p>We could in theory also provide forward secrecy with an RSA key exchange if
the server would generate an ephemeral RSA key pair, share its public key and
would then wait for the master secret to be sent by the client. As hinted above
RSA key generation is very expensive and does not scale in practice. That is
why RSA key exchanges are not a practical option for providing forward secrecy.</p>

<p>After both sides have agreed on session keys the TLS handshake is done and they
can finally start to communicate using symmetric encryption algorithms like
<a href="https://en.wikipedia.org/wiki/Advanced_Encryption_Standard">AES</a> that are
<em>much</em> faster than asymmetric algorithms.</p>

<h2><a name="the-cert"></a> The certificate</h2>

<p>Now that we understand authenticity is an integral part of TLS we know that in
order to serve a site via TLS we first need a certificate. The TLS protocol
can encrypt traffic between two parties just fine but the certificate provides
the necessary authentication towards visitors.</p>

<p>Without a certificate a visitor could securely talk to either us, the NSA, or
a different attacker but they probably want to talk to us. The certificate
ensures by cryptographic means that they established a connection to <em>our</em>
server.</p>

<h3>Selecting a Certificate Authority (CA)</h3>

<p>If you want a cheap certificate, have no specific needs, and only a single
subdomain (e.g. www) then StartSSL is an easy option. Do of course feel free
to take a look at different authorities - their services and prices will vary
heavily.</p>

<p>In the chain of trust the CA plays an important role: by verifying that you are
the rightful owner of your domain and signing your certificate it will let
browsers trust your certificate. The browsers do not want to do all this
verification themselves so they defer it to the CAs.</p>

<p>For your certificate you will need an RSA key pair, a public and private key.
The public key will be included in your certificate and thus also signed by the
CA.</p>

<h3>Generating an RSA key and a certificate signing request</h3>

<p>The example below shows how you can use OpenSSL on the command line to generate
a key for your domain. Simply replace <code>example.com</code> with the domain of your
website. <code>example.com.key</code> will be your new RSA key and <code>example.com.csr</code> will
be the
<a href="https://en.wikipedia.org/wiki/Certificate_signing_request">Certificate Signing Request</a>
that your CA needs to generate your certificate.</p>

<figure class='code'><div class="highlight"><pre>openssl req -new -newkey rsa:4096 -nodes -sha256 \
  -keyout example.com.key -out example.com.csr
</pre></div></figure>


<p>We will use a SHA-256 based signature for integrity as
<a href="https://blog.mozilla.org/security/2014/09/23/phasing-out-certificates-with-sha-1-based-signature-algorithms/">Firefox and Chrome will phase out support for SHA-1 based certificates soon</a>.
The RSA keys used to authenticate your website will use a 4096 bit modulus. If
you need to handle a lot of traffic or your server has a weak CPU you might
want to use 2048 bit. Never go below that as keys smaller than 2048 bit are
considered insecure.</p>

<h3>Get a signed certificate</h3>

<p>Sign up with the CA you chose and depending on how they handle this process you
probably will have to first verify that you are the rightful owner of the
domain that you claim to possess. StartSSL will do that by sending a token to
<code>postmaster@example.com</code> (or similar) and then ask you to confirm the receipt
of that token.</p>

<p>Now that you signed up and are the verified owner of <code>example.com</code> you simply
submit the <code>example.com.csr</code> file to request the generation of a certificate
for your domain. The CA will sign your public key and the other information
contained in the CSR with their private key and you can finally download the
certificate to <code>example.com.crt</code>.</p>

<p>Upload the .crt and .key files to your web server. Be aware that any
intermediate certificate in the CA&rsquo;s chain must be included in the .crt file as
well - you can just <code>cat</code> them together. StartSSL&rsquo;s free tier has an
intermediate Class 1 certificate - make sure to use
<a href="http://www.startssl.com/certs/class1/sha2/pem/sub.class1.server.sha2.ca.pem">the SHA-256 version</a>
of it. All files should be owned by root and must not be readable by anyone
else. Configure your web server to use those and you should probably have TLS
running configured out-of-the-box.</p>

<h2><a name="pfs"></a> (Perfect) Forward Secrecy</h2>

<p>To properly deploy TLS you will want to provide
<a href="http://vincent.bernat.im/en/blog/2011-ssl-perfect-forward-secrecy.html">(Perfect) Forward Secrecy</a>.
Without forward secrecy TLS still seems to secure your communication today, it
might however not if your private key is compromised in the future.</p>

<p>If a powerful adversary (think NSA) records all communication between a visitor
and your server, they can decrypt all this traffic years later by stealing your
private key or going the &ldquo;legal&rdquo; way to obtain it. This can be prevented by
using short-lived (ephemeral) keys for key exchanges that the server will
throw away after a short period.</p>

<h3>Diffie-Hellman key exchanges</h3>

<p>Using RSA with your certificate&rsquo;s private and public keys for key exchanges is
off the table as generating a 2048+ bit prime is very expensive. We thus need
to switch to ephemeral (Elliptic Curve) Diffie-Hellman cipher suites. For DH
you can generate a 2048 bit parameter once, choosing a private key afterwards
is cheap.</p>

<figure class='code'><div class="highlight"><pre>openssl dhparam -out dhparam.pem 2048
</pre></div></figure>


<p>Simply upload <code>dhparam.pem</code> to your server and instruct the web server to use
it for Diffie-Hellman key exchanges. When using ECDH the predefined elliptic
curve represents this parameter and no further action is needed.</p>

<figure class='code'><div class="highlight"><pre>(Nginx)
ssl_dhparam /path/to/ssl/dhparam.pem;
</pre></div></figure>


<p>Apache does unfortunately not support custom DH parameters, it is always set to
1024 bit and is not user configurable. This might hopefully be fixed in future
versions.</p>

<h3>Session IDs</h3>

<p>One of the most important mechanisms to improve TLS performance is
<a href="https://en.wikipedia.org/wiki/Transport_Layer_Security#Resumed_TLS_handshake">Session Resumption</a>.
In a full handshake the server sends a <em>Session ID</em> as part of the &ldquo;hello&rdquo;
message. On a subsequent connection the client can use this session ID and
pass it to the server when connecting. Because both the server and the client
have saved the last session&rsquo;s &ldquo;secret state&rdquo; under the session ID they can
simply resume the TLS session where they left off.</p>

<p>Now you might notice that this could violate forward secrecy as a compromised
server might reveal the secret state for all session IDs if the cache is just
large enough. The forward secrecy of a connection is thus bounded by how long
the session information is retained on the server. Ideally, your server would
use a medium-sized in-memory cache that is purged daily.</p>

<p>Apache lets you configure that using the <code>SSLSessionCache</code> directive and you
should use the high-performance cyclic buffer <code>shmcb</code>. Nginx has the
<code>ssl_session_cache</code> directive and you should use a <code>shared</code> cache that is
shared between workers. The right size of those caches would depend on the
amount of traffic your server handles. You want browsers to resume TLS sessions
but also get rid of old ones about daily.</p>

<h3>Session Tickets</h3>

<p>The second mechanism to resume a TLS session are
<a href="http://tools.ietf.org/html/rfc5077">Session Tickets</a>. This extension transmits
the server&rsquo;s secret state to the client, encrypted with a key only known to the
server. That ticket key is protecting the TLS connection now and in the future.</p>

<p>This might as well violate forward secrecy if the key used to encrypt session
tickets is compromised. The ticket (just as the session cache) contains all of
the server&rsquo;s secret state and would allow an attacker to reveal the whole
conversation.</p>

<p>Nginx and Apache by default generate a session ticket key at startup and do
unfortunately provide no way to rotate it. If your server is running for months
without a restart then you will use that same session ticket key for months and
breaking into your server could reveal every recorded TLS conversation since
the web server was started.</p>

<p>Neither Nginx nor Apache have a sane way to work around this, Nginx might be able to
<a href="http://forum.nginx.org/read.php?2,229538,230872#msg-230872">rotate the key by reloading the server config</a>
which is rather easy to implement with a cron job. Make sure to test that this
actually works before relying on it though.</p>

<p>Thus if you really want to provide forward secrecy you should disable session
tickets using <code>ssl_session_tickets off</code> for Nginx and <code>SSLOpenSSLConfCmd
Options -SessionTicket</code> for Apache.</p>

<h2><a name="cipher-suites"></a> Choosing the right cipher suites</h2>

<p><a href="https://wiki.mozilla.org/Security/Server_Side_TLS#Modern_compatibility">Mozilla&rsquo;s guide on server side TLS</a>
provides a great list of modern cipher suites that needs to be put in your web
server&rsquo;s configuration. The combinations below are unfortunately supported by
only modern browsers, for broader client support you might want to consider
using the &ldquo;intermediate&rdquo; list.</p>

<figure class='code'><div class="highlight"><pre>ECDHE-RSA-AES128-GCM-SHA256:   \
ECDHE-ECDSA-AES128-GCM-SHA256: \
ECDHE-RSA-AES256-GCM-SHA384:   \
ECDHE-ECDSA-AES256-GCM-SHA384: \
DHE-RSA-AES128-GCM-SHA256:     \
DHE-DSS-AES128-GCM-SHA256:     \
[...]
!aNULL:!eNULL:!EXPORT:!DES:!RC4:!3DES:!MD5:!PSK
</pre></div></figure>


<p>All these cipher suites start with (EC)DHE which means they only support
ephemeral Diffie-Hellman key exchanges for forward secrecy. The last line
discards non-authenticated key exchanges, null-encryption (cleartext), legacy
weak ciphers marked exportable by US law, weak ciphers (3)DES and RC4, weak MD5
signatures, and pre-shared keys.</p>

<blockquote><p>Note: To ensure that the order of cipher suites is respected you need to set
<code>ssl_prefer_server_ciphers on</code> for Nginx or <code>SSLHonorCipherOrder on</code> for
Apache.</p></blockquote>

<h2><a name="hsts"></a> HTTP Strict Transport Security (HSTS)</h2>

<p>Now that your server is configured to accept TLS connections you still want to
support HTTP connections on port 80 to redirect old links and folks typing
<code>example.com</code> in the URL bar to your shiny new HTTPS site.</p>

<p>At this point however a <a href="https://en.wikipedia.org/wiki/Man-in-the-middle_attack">Man-In-The-Middle</a>
(or Woman-In-The-Middle) attack can easily intercept and modify traffic to
deliver a forged HTTP version of your site to a visitor. The poor visitor might
never know because they did not realize you offer TLS connections now.</p>

<p>To ensure your users are secured when visiting your site the next time you
want to send a HSTS header to enforce
<a href="https://tools.ietf.org/html/rfc6797">strict transport security</a>.
By sending this header the browser will not try to establish a HTTP connection
next time but directly connect to your website via TLS.</p>

<figure class='code'><div class="highlight"><pre>Strict-Transport-Security:
  max-age=15768000; includeSubDomains; preload
</pre></div></figure>


<p>Sending these headers over a HTTPS connection (they will be ignored via HTTP)
lets the browser remember that this domain wants strict transport security for
the next six months (~15768000 seconds). The <code>includeSubDomains</code> token enforces
TLS connections for every subdomain of your domain and the non-standard
<code>preload</code> token will be required for the next section.</p>

<h2><a name="hsts-preload"></a> HSTS Preload List</h2>

<p>If after deploying TLS the very first connection of a visitor is genuine we are
fine. Your server will send the HSTS header over TLS and the visitor&rsquo;s browser
remembers to use TLS in the future. The very first connection and every
connection after the HSTS header expires however are still vulnerable to a
MITM attack.</p>

<p>To prevent this Firefox and Chrome share a
<a href="https://chromium.googlesource.com/chromium/src/net/+/master/http/transport_security_state_static.json">HSTS Preload List</a>
that basically includes HSTS headers for all sites that would send that header
when visiting anyway. So before connecting to a host Firefox and Chrome check
whether that domain is in the list and if so would not even try using an
insecure HTTP connection.</p>

<p>Including your page in that list is easy, just submit your domain using the
<a href="http://hstspreload.appspot.com/">HSTS Preload List submission form</a>. Your
HSTS header must be set up correctly and contain the <code>includeSubDomains</code> and
<code>preload</code> tokens to be accepted.</p>

<h2><a name="ocsp-stapling"></a> OCSP Stapling</h2>

<p><a href="https://en.wikipedia.org/wiki/Online_Certificate_Status_Protocol">OCSP</a> -
using an external server provided by the CA to check whether the certificate
given by the server was revoked - might sound like a great idea at first. On
the second thought it actually sounds rather terrible. First, the CA providing
the OCSP server suddenly has to be able to handle a lot of requests: every
client opening a connection to your server will want to know whether your
certificate was revoked before talking to you.</p>

<p>Second, the browser contacting a CA and passing the certificate is an easy way
to monitor a user&rsquo;s browsing behavior. If all CAs worked together they probably
could come up with a nice data set of TLS sites that people visit, when and in
what order (not that I know of any plans they actually wanted to do that).</p>

<h3>Let the server do the work for your visitors</h3>

<p><a href="https://tools.ietf.org/html/rfc6066#section-8">OCSP Stapling</a> is a TLS
extension that enables the server to query its certificate&rsquo;s revocation status
at regular intervals in the background and send an OCSP response with the TLS
handshake. The stapled response itself cannot be faked as it needs to be
signed with the CA&rsquo;s private key. Enabling OCSP stapling thus improves
performance and privacy for your visitors immediately.</p>

<p>You need to create a certificate file that contains your CA&rsquo;s root certificate
prepended by any intermediate certificates that might be in your CA&rsquo;s chain.
StartSSL has an intermediate certificate for Class 1 (the free tier) - make
sure to use
<a href="http://www.startssl.com/certs/class1/sha2/pem/sub.class1.server.sha2.ca.pem">the one having the SHA-256 signature</a>.
Pass the file to Nginx using the <code>ssl_trusted_certificate</code> directive and to
Apache using the <code>SSLCACertificateFile</code> directive.</p>

<h3>OCSP Must Staple</h3>

<p>OCSP however is unfortunately not a silver bullet. If a browser does not know
in advance it will receive a stapled response then the attacker might as well
redirect HTTPS traffic to their server and block any traffic to the OCSP server
(in which case browsers soft-fail).
<a href="https://www.imperialviolet.org/2014/04/19/revchecking.html">Adam Langley explains</a>
all possible attack vectors in great detail.</p>

<p>One solution might be the proposed
<a href="https://tools.ietf.org/html/draft-hallambaker-muststaple-00">OCSP Must Staple Extension</a>.
This would add another field to the certificate issued by the CA that says a
server <em>must</em> provide a stapled OCSP response. The problem here is that the
proposal expired and in practice it would take years for CAs to support that.</p>

<p>Another solution would be to implement
<a href="https://bugzilla.mozilla.org/show_bug.cgi?id=901698">a header similar to HSTS</a>,
that lets the browser remember to require a stapled OCSP response when
connecting next time. This however has the same problems on first connection
just like HSTS, and we might have to maintain a &ldquo;OCSP-Must-Staple Preload List&rdquo;.
As of today there is unfortunately no immediate solution in sight.</p>

<h2><a name="hpkp"></a> HTTP Public Key Pinning (HPKP)</h2>

<p>Even with all those security checks when receiving the server&rsquo;s certificate
we would still be completely out of luck in case your
<a href="http://en.wikipedia.org/wiki/DigiNotar">CA&rsquo;s private key is compromised</a> or
your <a href="http://nakedsecurity.sophos.com/2013/01/08/the-turktrust-ssl-certificate-fiasco-what-happened-and-what-happens-next/">CA simply fucks up</a>.
We can prevent these kinds of attacks with an HTTP extension called
<a href="https://tools.ietf.org/html/draft-ietf-websec-key-pinning-21">Public Key Pinning</a>.</p>

<p>Key pinning is a trust-on-first-use (TOFU) mechanism. The first time a browser
connects to a host it lacks the the information necessary to perform &ldquo;pin
validation&rdquo; so it will not be able to detect and thwart a MITM attack. This
feature only allows detection of these kinds of attacks after the first
connection.</p>

<h3>Generating a HPKP header</h3>

<p><a href="https://developer.mozilla.org/en-US/docs/Web/Security/Public_Key_Pinning">Creating an HPKP header is easy</a>,
all you need to do is to compute the base64-encoded &ldquo;SPKI fingerprint&rdquo; of your
server&rsquo;s certificate. An SPKI fingerprint is the output of applying SHA-256
to the public key information contained in your certificate.</p>

<figure class='code'><div class="highlight"><pre>openssl req -inform pem -pubkey -noout &lt; example.com.csr |
  openssl pkey -pubin -outform der |
  openssl dgst -sha256 -binary |
  base64
</pre></div></figure>


<p>The result of running the above command can be directly used as the
<em>pin-sha256</em> values for the <em>Public-Key-Pins</em> header as shown below:</p>

<figure class='code'><div class="highlight"><pre>Public-Key-Pins:
  pin-sha256=&quot;GRAH5Ex+kB4cCQi5gMU82urf+6kEgbVtzfCSkw55AGk=&quot;;
  pin-sha256=&quot;lERGk61FITjzyKHcJ89xpc6aDwtRkOPAU0jdnUqzW2s=&quot;;
  max-age=15768000; includeSubDomains
</pre></div></figure>


<p>Upon receiving this header the browser knows that it has to store the pins
given by the header and discard any certificates whose SPKI fingerprints do
not match for the next six months (max-age=15768000). We specified the
<code>includeSubDomains</code> token so the browser will verify pins when connecting
to any subdomain.</p>

<h3>Include the pin of a backup key</h3>

<p>It is considered good practice to include at least a second pin, the SPKI
fingerprint of a backup RSA key that you can generate exactly as the original
one:</p>

<figure class='code'><div class="highlight"><pre>openssl req -new -newkey rsa:4096 -nodes -sha256 \
  -keyout example.com.backup.key -out example.com.backup.csr
</pre></div></figure>


<p>In case your private key is compromised you might need to revoke your
current certificate and request the CA to issue a new one. The old pin however
would still be stored in browsers for six months which means they would not
be able to connect to your site. By sending two <em>pin-sha256</em> values the browser
will later accept a TLS connection when any of the stored fingerprints match
the given certificate.</p>

<h2><a name="attacks"></a> Known attacks</h2>

<p>In the past years (and especially the last year) a few attacks on SSL/TLS were
published. Some of those attacks can be worked around on the protocol or crypto
library level so that you basically do not have to worry as long as your web
server is up to date and the visitor is using a modern browser. A few attacks
however need to be thwarted by configuring your server properly.</p>

<h3>BEAST (Browser Exploit Against SSL/TLS)</h3>

<p><a href="http://blog.cryptographyengineering.com/2011/09/brief-diversion-beast-attack-on-tlsssl.html">BEAST</a>
is an attack that only affects TLSv1.0. Exploiting this vulnerability is
possible but rather difficult. You can either disable TLSv1.0 completely -
which is certainly the preferred solution although you might neglect folks
with old browsers on old operating systems - or you can just not worry. All
major browsers have implemented workarounds so that it should not be an issue
anymore in practice.</p>

<h3>BREACH (Browser Reconnaissance and Exfiltration via Adaptive Compression of Hypertext)</h3>

<p><a href="https://en.wikipedia.org/wiki/BREACH_%28security_exploit%29">BREACH</a> is a
security exploit against HTTPS when using HTTP compression. BREACH is based
on <a href="https://en.wikipedia.org/wiki/CRIME">CRIME</a> but unlike CRIME - which can be
successfully defended by turning off TLS compression (which is the default
for Nginx and Apache nowadays) - BREACH can only be prevented by turning off
HTTP compression. Another method to mitigate this would be to use
<a href="https://en.wikipedia.org/wiki/Cross-site_request_forgery">cross-site request forgery (CSRF)</a>
protection or
<a href="https://community.qualys.com/blogs/securitylabs/2013/08/07/defending-against-the-breach-attack">disable HTTP compression selectively based on headers</a>
sent by the application.</p>

<h3>POODLE (Padding Oracle On Downgraded Legacy Encryption)</h3>

<p><a href="https://en.wikipedia.org/wiki/POODLE">POODLE</a>
is yet another
<a href="https://en.wikipedia.org/wiki/Padding_oracle_attack">padding oracle attack</a> on
TLS. Luckily it only affects the predecessor of TLS which is SSLv3. The only
solution when deploying a new server is to just disable SSLv3 completely.
Fortunately, we already excluded SSLv3 in our list of preferred ciphers
previously. Firefox 34 will ship with SSLv3 disabled by default, Chrome and
others will hopefully follow soon.</p>

<h2>Further reading</h2>

<p>Thanks for reading and I am really glad you made it that far! I hope this post
did not discourage you from deploying TLS - after all getting your setup right
is the most important thing. And it certainly is better to to know what you are
getting yourselves into than leaving your visitors unprotected.</p>

<p>If you want to read even
more about setting up TLS, the Mozilla Wiki page on
<a href="https://wiki.mozilla.org/Security/Server_Side_TLS">Server-Side TLS</a> has more
information and proposed web server configurations.</p>

<blockquote><p>Thanks a lot to <a href="https://frederik-braun.com/">Frederik Braun</a> for taking the
time to proof-read this post and helping to clarify a few things!</p></blockquote>

  </div>
</article>

  </section>

  <footer>
  <div class="container">
    <span class="break">&#8203;</span><div class="section">
      <a class="main" href="/">Tim Taubert</a>
      <span class="job">Security &amp; Crypto Engineer</span>
      <a class="license" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a>
      <a href="https://twitter.com/ttaubert">@ttaubert</a>
    </div>
    <span class="break">&#8203;</span><div class="section short1">
      <span class="job">Security &amp; Crypto Engineer</span>
      <a class="license" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a>
      <a href="https://twitter.com/ttaubert">@ttaubert</a>
    </div>
    <span class="break">&#8203;</span><div class="section short2">
      <a class="license" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a>
      <a href="https://twitter.com/ttaubert">@ttaubert</a>
    </div>
    <div class="section short3">
      <a class="license" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a>
    </div>
  </div>
  <a class="imprint collapse" href="/impressum">Impressum</a>
</footer>

</body>
</html>
